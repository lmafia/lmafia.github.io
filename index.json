[{"categories":["techology"],"content":"数学公式在编程里的应用: 整数向上取整公式，常用于分页，分片的场景 ","date":"2025-05-23","objectID":"/ceil-for-integers/:0:0","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#"},{"categories":["techology"],"content":" 背景在用 AI 编程的时候，让它给我生成一个分页处理的工具类: java public static \u003cT\u003e List\u003cT\u003e paginate(List\u003cT\u003e list, int page, int pageSize) { if (list == null || list.isEmpty()) { return Collections.emptyList(); } if (pageSize \u003c= 0) { throw new IllegalArgumentException(\"pageSize must be greater than 0\"); } int total = list.size(); int totalPages = (total + pageSize - 1) / pageSize; int safePage = Math.max(1, page); if (safePage \u003e totalPages) { return Collections.emptyList(); } int skip = (safePage - 1) * pageSize; return list.stream() .skip(skip) .limit(pageSize) .collect(Collectors.toList()); } 在 Review 生成代码的时候，发现求总页数的计算让我有点好奇，为什么它用这个公式 求总页数: 总数除于分页大小, 如果余数大 0，就加一。在编程里，整数相除一般是向下取整，我第一反应想到的逻辑是：先除，后取模，根据取模结果判断是否 +1，btw，看 Mybatis Plus 的代码，发现他也是这么设计的: java /** * 当前分页总页数 */ default long getPages() { if (getSize() == 0) { return 0L; } long pages = getTotal() / getSize(); if (getTotal() % getSize() != 0) { pages++; } return pages; } 所以 AI 给我的这个计算方式着实让我好奇: (total + pageSize - 1) / pageSize; 我很好奇，为什么是加b-1 和除以b 所以后来，我向 Chapt 老师请教了如何证明这个公式是有效的。 ","date":"2025-05-23","objectID":"/ceil-for-integers/:1:0","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#背景"},{"categories":["techology"],"content":" 证明过程“向上取整除法”的核心公式是： ⌈ab⌉=a+b−1b \\left\\lceil \\frac{a}{b} \\right\\rceil = \\frac{a + b - 1}{b} ⌈ba​⌉=ba+b−1​前提： a ≥ 0, b \u003e 0 除法采用整数除法（向下取整） 所有变量为整数 ","date":"2025-05-23","objectID":"/ceil-for-integers/:2:0","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#证明过程"},{"categories":["techology"],"content":" 目标我们要证明这个公式： ⌈ab⌉=a+b−1b \\left\\lceil \\frac{a}{b} \\right\\rceil = \\frac{a + b - 1}{b} ⌈ba​⌉=ba+b−1​右边是整数除法（向下取整），但通过 +b-1 的技巧实现了向上取整效果。 ","date":"2025-05-23","objectID":"/ceil-for-integers/:2:1","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#目标"},{"categories":["techology"],"content":" 整数除法基础（商和余）设 a = bq + r，其中： q = a / b 是向下取整的商 r = a % b 是余数，满足 0 ≤ r \u003c b 因此： 如果 r = 0：说明 a 被 b 整除，结果无需进位。 如果 r \u003e 0：则需进一位，即向上取整。 ","date":"2025-05-23","objectID":"/ceil-for-integers/:2:2","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#整数除法基础商和余"},{"categories":["techology"],"content":" 定义定义： ⌈ab⌉={q,if r=0q+1,if r\u003e0 \\left\\lceil \\frac{a}{b} \\right\\rceil = \\begin{cases} q, \u0026 \\text{if } r = 0 \\\\ q + 1, \u0026 \\text{if } r \u003e 0 \\end{cases} ⌈ba​⌉={q,q+1,​if r=0if r\u003e0​","date":"2025-05-23","objectID":"/ceil-for-integers/:2:3","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#定义"},{"categories":["techology"],"content":" 分情况讨论 当 r = 0 时 a = bq a + b - 1 = bq + b - 1 = b(q + 1) - 1 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: a+b−1b=bq+b−1bq+(b−1b) \\frac{a + b - 1}{b} = \\frac{bq + b - 1}{b} q + \\left( \\frac{b - 1}{b} \\right) ba+b−1​=bbq+b−1​q+(bb−1​)因为整数除法是向下取整的， (b - 1) \u003c b , 所以 (b - 1)/b 为 0 所以证明得 a+b−1b=b(q+1)−1b=q \\frac{a + b - 1}{b} = \\frac{b(q + 1) - 1}{b} = q ba+b−1​=bb(q+1)−1​=q 当 r \u003e 0 时 a = bq + r, 0 \u003c r \u003c b a + b - 1 = bq + r + b - 1 = b(q + 1) + (r - 1) 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: (a+b−1b)=(b(q+1)+(r−1)b)=(q+1)+(r−1b) \\left( \\frac{a + b - 1}{b} \\right) = \\left( \\frac{b(q + 1) + (r - 1)}{b} \\right) = (q + 1) + \\left( \\frac{r - 1}{b} \\right) (ba+b−1​)=(bb(q+1)+(r−1)​)=(q+1)+(br−1​)讨论 (r - 1) 和 b 因为 0 \u003c r \u003c b , 所以 -1 \u003c r - 1 \u003c b - 1 \u003c b 得 r-1 \u003c b 所以 (r−1b)=0 \\left( \\frac{r - 1}{b} \\right) = 0 (br−1​)=0所以证明得, 当 r \u003e 0 时 a+b−1b=(q+1)+0=q+1 \\frac{a + b - 1}{b} = (q + 1) + 0 = q + 1 ba+b−1​=(q+1)+0=q+1","date":"2025-05-23","objectID":"/ceil-for-integers/:2:4","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#分情况讨论"},{"categories":["techology"],"content":" 分情况讨论 当 r = 0 时 a = bq a + b - 1 = bq + b - 1 = b(q + 1) - 1 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: a+b−1b=bq+b−1bq+(b−1b) \\frac{a + b - 1}{b} = \\frac{bq + b - 1}{b} q + \\left( \\frac{b - 1}{b} \\right) ba+b−1​=bbq+b−1​q+(bb−1​)因为整数除法是向下取整的， (b - 1) \u003c b , 所以 (b - 1)/b 为 0 所以证明得 a+b−1b=b(q+1)−1b=q \\frac{a + b - 1}{b} = \\frac{b(q + 1) - 1}{b} = q ba+b−1​=bb(q+1)−1​=q 当 r \u003e 0 时 a = bq + r, 0 \u003c r \u003c b a + b - 1 = bq + r + b - 1 = b(q + 1) + (r - 1) 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: (a+b−1b)=(b(q+1)+(r−1)b)=(q+1)+(r−1b) \\left( \\frac{a + b - 1}{b} \\right) = \\left( \\frac{b(q + 1) + (r - 1)}{b} \\right) = (q + 1) + \\left( \\frac{r - 1}{b} \\right) (ba+b−1​)=(bb(q+1)+(r−1)​)=(q+1)+(br−1​)讨论 (r - 1) 和 b 因为 0 \u003c r \u003c b , 所以 -1 \u003c r - 1 \u003c b - 1 \u003c b 得 r-1 \u003c b 所以 (r−1b)=0 \\left( \\frac{r - 1}{b} \\right) = 0 (br−1​)=0所以证明得, 当 r \u003e 0 时 a+b−1b=(q+1)+0=q+1 \\frac{a + b - 1}{b} = (q + 1) + 0 = q + 1 ba+b−1​=(q+1)+0=q+1","date":"2025-05-23","objectID":"/ceil-for-integers/:2:4","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#当-r--0-时"},{"categories":["techology"],"content":" 分情况讨论 当 r = 0 时 a = bq a + b - 1 = bq + b - 1 = b(q + 1) - 1 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: a+b−1b=bq+b−1bq+(b−1b) \\frac{a + b - 1}{b} = \\frac{bq + b - 1}{b} q + \\left( \\frac{b - 1}{b} \\right) ba+b−1​=bbq+b−1​q+(bb−1​)因为整数除法是向下取整的， (b - 1) \u003c b , 所以 (b - 1)/b 为 0 所以证明得 a+b−1b=b(q+1)−1b=q \\frac{a + b - 1}{b} = \\frac{b(q + 1) - 1}{b} = q ba+b−1​=bb(q+1)−1​=q 当 r \u003e 0 时 a = bq + r, 0 \u003c r \u003c b a + b - 1 = bq + r + b - 1 = b(q + 1) + (r - 1) 代入 a+b−1b \\frac{a + b - 1}{b} ba+b−1​得到: (a+b−1b)=(b(q+1)+(r−1)b)=(q+1)+(r−1b) \\left( \\frac{a + b - 1}{b} \\right) = \\left( \\frac{b(q + 1) + (r - 1)}{b} \\right) = (q + 1) + \\left( \\frac{r - 1}{b} \\right) (ba+b−1​)=(bb(q+1)+(r−1)​)=(q+1)+(br−1​)讨论 (r - 1) 和 b 因为 0 \u003c r \u003c b , 所以 -1 \u003c r - 1 \u003c b - 1 \u003c b 得 r-1 \u003c b 所以 (r−1b)=0 \\left( \\frac{r - 1}{b} \\right) = 0 (br−1​)=0所以证明得, 当 r \u003e 0 时 a+b−1b=(q+1)+0=q+1 \\frac{a + b - 1}{b} = (q + 1) + 0 = q + 1 ba+b−1​=(q+1)+0=q+1","date":"2025-05-23","objectID":"/ceil-for-integers/:2:4","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#当-r--0-时-1"},{"categories":["techology"],"content":" 结语因为只是涉及整数的运算，用不到浮点运算比 JDK Math提供的 ceil 更适合分页的场景 除此之外，还能用: 底层的 内存块 / 缓冲区申请 btw, 和公司的嵌入式同事强哥提到的时候，他已经使用过了，对于嵌入式开发来说比较常用 文件的分块 ，以实现断点续传或分块并行下载 分布式任务调度的 分片计算 大数据任务计算的 批处理 ","date":"2025-05-23","objectID":"/ceil-for-integers/:3:0","series":null,"tags":["Java","函数编程"],"title":"整数向上取整公式证明","uri":"/ceil-for-integers/#结语"},{"categories":["techology"],"content":" 现在是什么问题?最近开发环境有个服务只要是超过 2 天没有重启/构建上线的话, 都会出现请求超时的问题.弄的前端和嵌入式开发的同事老是找我麻烦 😅 周末刚好有空去加班, 办公室也比较安静, 比较有耐心来排查这个问题了. 开发环境虽然是个直接 java -jar 部署的, 因为有用 mircometer 来暴露一些监控数据, 我也是把它接入了监控了, 在 Grafana 就能看到 JVM 情况 Grafana - JVM 可以看到 Thread 和 Waithing 状态的 Thread 不断增加, 怎么了, 看起来是线程泄漏了? 我们的代码虽然管理是不规范, 到处都有地方开线程池, 但是之前还是用的好好的呀「手动狗头」 没事没事, 知道有异常出现了, 都好办, 直接上去机器上 dump 一些 log 出来看看就好, 我们这不还在「犯罪现场」呢嘛 ","date":"2025-05-11","objectID":"/debug-tomcat-thread-issue/:1:0","series":null,"tags":["Java","Tomcat","SpringBoot"],"title":"SpringWeb 线程泄漏问题排查","uri":"/debug-tomcat-thread-issue/#现在是什么问题"},{"categories":["techology"],"content":" 看看怎么个事儿开发环境都是丢在一台虚拟机上的, 而且就是直接 java -jar 部署的 天然的让我好把日志导出来, 我直接一个 jps -lvm 查看那个问题服务的 PID 然后再来一个 jstack: 通过 jstack pid \u003e thread_dump.log 把线程和上下文都 dump 出来 然后再来请上我们的 Linux 三剑客之二: awk, grep 这里你以为我的 Linux 命令用的很溜嘛? 其实都是 ChatGPT 给我的, 没了他我可就是个菜鸡 😭 执行: bash awk '/^\"/ {thread=$0} /java.lang.Thread.State: WAITING/ {print thread}' thread_dump.log | awk -F'\"' '{print $2}' | tee /dev/tty | wc -l 输出: jstack 统计 好家伙, 大部分都是 http-nio-exec-* 证明都是请求没有释放还是咋地啊？ 咱们可是都是 Spring Boot 工程师呢 , 用得当然是我们的 SpringBoot + SpringWeb (Tomcat 内置) 我们最近也没升级啥 Tomcat 的版本, 也没修改什么配置的, 到底咋个回事? 挑几个请求的线程看看日志吧, 发现基本都处在 WAITING（Park）状态 http-nio-exec 上下文 而且几乎所有 WAITING 状态的都来自 Druid 数据库连接池获取不到链接, 争抢锁 🔒 时获取不到, 一直等待其他链接的释放. com.alibaba.druid.pool.DruidDataSource#getConnectionInternal 我们的在服务配置的 max-active = 20, 说明 20 个链接可能都被占着, 一直没还回去. 难道是高并发? 是不是要直接把 max-active 调大就可以解决？ 如果我是初级开发, 我可能就会认为这样就能解决了, 毕竟舔了这堆屎山 💩 已经近 3 年之久, 我的直觉告诉我肯定是哪里有 Bug 导致的 因为还没给 Druid 配置连接泄漏检测, 所以只能通过业务日志排查.因为是一直有线程占数据库连接「不拉屎」, 导致后面的请求「拉不了屎」, 所以我们可以从日志最前面的几个 http 请求线程来看. 发现均来自给设备升级的业务, 这个业务的接口在开发环境一般是了半夜 2 点定时任务触发的, 很少在从客户端请求 ","date":"2025-05-11","objectID":"/debug-tomcat-thread-issue/:2:0","series":null,"tags":["Java","Tomcat","SpringBoot"],"title":"SpringWeb 线程泄漏问题排查","uri":"/debug-tomcat-thread-issue/#看看怎么个事儿"},{"categories":["techology"],"content":" 有点眉目了本来想看能不能知道几个线程的存活时间, 通过存活时间来推算日志时间来看业务日志, 转念一想, 都已知具体触发时间, 就搭配线程名和业务关键来过滤日志吧, 就在日志的海洋 🌊 里遨游吧, 骚年 排查了好一会儿, 突然发现有几个 Feign 的调用是报错的, 通过 trace 来看, 看到本应该 2 点开始出发的请求, 在 9 点还有一个报错堆栈: wait 报错堆栈 奇怪, 怎么有一个 wait 被中断的报错, 而且在 过了 7 个小时才被中断. bash java.lang.InterruptedException: null at java.base/java.lang.Object.wait0(Native Method) at java.base/java.lang.Object.wait(Object.java:366) 找到对应的代码, 发现是同事在解耦一个业务的时候, 想把一个兜底的定时任务去掉, 写成了一个 while(可能会真) 里加了个 object.wait(时间). 那么我们看下这几个一直 wait 的请求吧.对了, 这里的线程应该是为 TIMED_WAITING 状态, 因为是加了等待时间的, 只是一直在 while 里出不来. ","date":"2025-05-11","objectID":"/debug-tomcat-thread-issue/:3:0","series":null,"tags":["Java","Tomcat","SpringBoot"],"title":"SpringWeb 线程泄漏问题排查","uri":"/debug-tomcat-thread-issue/#有点眉目了"},{"categories":["techology"],"content":" 终于捉到虫再次请出我们的 Linux 剑客帮帮忙吧, 记得把想要找的线程状态改为 TIMED_WAITING bash awk '/^\"/ {thread=$0} /java.lang.Thread.State: TIMED_WAITING/ {print thread}' thread_dump.log | awk -F'\"' '{print $2}' 输出内容: TIMED_WAITING 线程们 看了除了 http-nio-exec-280 外的日志, 都是卡在出问题的代码上: TIMED_WAITING 报错 而且刚好数量和配置的 Druid 的 max-active 一致, 这个 Bug 就在这里被排查出来了. 因为有个监控会定时调用「登陆」接口来判断服务是否正常, 所以后面 200+ 个请求积压都是来自「登陆」接口. ","date":"2025-05-11","objectID":"/debug-tomcat-thread-issue/:4:0","series":null,"tags":["Java","Tomcat","SpringBoot"],"title":"SpringWeb 线程泄漏问题排查","uri":"/debug-tomcat-thread-issue/#终于捉到虫"},{"categories":["techology"],"content":" 学到了啥和以前排查 bug 不同的是, 这次排查问题读组件源码, 通过报错堆栈搜问题, 以前会在首先会 Google 搜索, 现在首先是发给 ChatGPT. 虽然 AI 输出的内容可能比较全面, 但是还是会误导我们, 比如这次解决问题时候, 他因为不知道我们业务代码, 第一时间是让我修改数据库连接池的最大活跃数, 都是一个治标不治本的做法, 如果想要思考问题透彻点, 还是多问 Why, 多用第一性原理分析 🧐 ","date":"2025-05-11","objectID":"/debug-tomcat-thread-issue/:5:0","series":null,"tags":["Java","Tomcat","SpringBoot"],"title":"SpringWeb 线程泄漏问题排查","uri":"/debug-tomcat-thread-issue/#学到了啥"},{"categories":["techology"],"content":"如何用 Java 使用高阶函数 ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:0","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#"},{"categories":["techology"],"content":" Funciton 接口的定义 Java /** * Represents a function that accepts one argument and produces a result. * * \u003cp\u003eThis is a \u003ca href=\"package-summary.html\"\u003efunctional interface\u003c/a\u003e * whose functional method is {@link #apply(Object)}. * * @param \u003cT\u003e the type of the input to the function * @param \u003cR\u003e the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function\u003cT, R\u003e {} ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:1","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#funciton-接口的定义"},{"categories":["techology"],"content":" 代码示例实现功能: 2 次函数 apply 3 次函数 apply Java public static void main(String[] args) { Function\u003cFunction\u003cInteger, Integer\u003e, Function\u003cInteger, Integer\u003e\u003e applyTwice = //f(f(x)) f -\u003e x -\u003e f.apply(f.apply(x)); Function\u003cFunction\u003cInteger, Integer\u003e, Function\u003cInteger, Integer\u003e\u003e applyThrice = f -\u003e { return x -\u003e { //f(f(f(x))) return f.apply(f.apply(f.apply(x))); }; }; System.out.println(applyThrice.apply( x -\u003e x + 1 ).apply(0)); } ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:2","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#代码示例"},{"categories":["techology"],"content":" 第一层：最外层 Function Java Function\u003cFunction\u003cInteger, Integer\u003e, Function\u003cInteger, Integer\u003e\u003e 这个类型的输入是 Function\u003cInteger, Integer\u003e 输出也是 Function\u003cInteger, Integer\u003e。 换句话说，这个高阶函数的作用是： 接收一个函数 Funciotn\u003cInterger, Integer\u003e 返回一个新的函数 Function\u003cInteger, Integer\u003e， ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:3","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#第一层最外层-function"},{"categories":["techology"],"content":" 第二层：输入参数Function\u003cInteger, Integer\u003e 这是 Java 函数接口, 输入输出参数都是 Integer 比如： Function\u003cInteger, Integer\u003e increment = x -\u003e x + 1; Function\u003cInteger, Integer\u003e square = x -\u003e x * x; 这些都是 Function\u003cInteger, Integer\u003e 类型的函数。 ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:4","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#第二层输入参数"},{"categories":["techology"],"content":" 第三层 返回值 Function\u003cInteger, Integer\u003e最后 applyThrice 应该返回的是一个Function\u003cInteger, Integer\u003e 拆解下 applyThrice.apply( x -\u003e x + 1 ).apply(0) applyThrice.apply( x -\u003e x + 1 ) 返回了: x -\u003e ( ( ( x + 1 ) + 1 ) + 1 ) .apply(0) 就是把 0 作为输入 x ( ( ( 0 + 1 ) + 1 ) + 1 ) 结果为 3 ","date":"2025-03-19","objectID":"/fucniton-for-java/:0:5","series":null,"tags":["Java","函数编程"],"title":"用 Java 来实现高阶函数","uri":"/fucniton-for-java/#第三层-返回值-functioninteger-integer"},{"categories":null,"content":" 我是谁Hi, 我是 Kyle Lian 软件开发, 涉及过数字城市、海外广告和智能家居 一位 Apple 产品重度用户, 拥有 Apple 全家桶 目前正在和 AI 一起做一些有意思的事情 喜欢的编程风格 OOP, FP 后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor ","date":"2025-03-19","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#我是谁"},{"categories":null,"content":" 我是谁Hi, 我是 Kyle Lian 软件开发, 涉及过数字城市、海外广告和智能家居 一位 Apple 产品重度用户, 拥有 Apple 全家桶 目前正在和 AI 一起做一些有意思的事情 喜欢的编程风格 OOP, FP 后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor ","date":"2025-03-19","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#后端"},{"categories":null,"content":" 我是谁Hi, 我是 Kyle Lian 软件开发, 涉及过数字城市、海外广告和智能家居 一位 Apple 产品重度用户, 拥有 Apple 全家桶 目前正在和 AI 一起做一些有意思的事情 喜欢的编程风格 OOP, FP 后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor ","date":"2025-03-19","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#前端"},{"categories":null,"content":" 我是谁Hi, 我是 Kyle Lian 软件开发, 涉及过数字城市、海外广告和智能家居 一位 Apple 产品重度用户, 拥有 Apple 全家桶 目前正在和 AI 一起做一些有意思的事情 喜欢的编程风格 OOP, FP 后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor ","date":"2025-03-19","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#devops"},{"categories":null,"content":" 我是谁Hi, 我是 Kyle Lian 软件开发, 涉及过数字城市、海外广告和智能家居 一位 Apple 产品重度用户, 拥有 Apple 全家桶 目前正在和 AI 一起做一些有意思的事情 喜欢的编程风格 OOP, FP 后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor ","date":"2025-03-19","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于","uri":"/about/#开发工具"},{"categories":null,"content":" 其他 Ubuntu, CentOS Markdown Logseq ","date":"2025-03-19","objectID":"/about/:1:1","series":null,"tags":null,"title":"关于","uri":"/about/#其他"},{"categories":null,"content":" 网站历史2024-09-25: 配置自定义域名 2023-09-29: 通过 Hugo + GithubPages 搭建 ","date":"2025-03-19","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于","uri":"/about/#网站历史"},{"categories":["techology"],"content":"通过脑图详细解析 LangChain4J 的功能架构和应用场景","date":"2025-02-20","objectID":"/langchain4j-tool/","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/"},{"categories":["techology"],"content":" LangChain4J 功能架构mindmap root((LangChain4J)) 模型集成 OpenAI ChatGPT GPT-4 Azure OpenAI Anthropic Claude 本地模型 Ollama 核心功能 Prompt Engineering PromptTemplate Few-shot Learning Chain of Thought Memory 消息记忆 对话历史 向量存储 Embedding 文本向量化 相似度搜索 知识库构建 工具集成 RAG 文档加载器 文本分割 向量数据库 Agent 工具调用 任务规划 自主决策 应用场景 智能客服 多轮对话 知识库问答 意图识别 文档处理 自动摘要 信息提取 文档分类 代码助手 代码生成 代码解释 Bug分析 ","date":"2025-02-20","objectID":"/langchain4j-tool/:1:0","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#langchain4j-功能架构"},{"categories":["techology"],"content":" 功能模块详解","date":"2025-02-20","objectID":"/langchain4j-tool/:2:0","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#功能模块详解"},{"categories":["techology"],"content":" 1. 模型集成LangChain4J 支持多种大语言模型的接入，包括： OpenAI 的 GPT 系列 Azure OpenAI 服务 Anthropic Claude 本地部署的开源模型 ","date":"2025-02-20","objectID":"/langchain4j-tool/:2:1","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#1-模型集成"},{"categories":["techology"],"content":" 2. 核心功能核心功能模块提供了构建 AI 应用的基础能力： Prompt 工程：模板管理和优化 记忆系统：对话历史管理 向量计算：文本嵌入和相似度计算 ","date":"2025-02-20","objectID":"/langchain4j-tool/:2:2","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#2-核心功能"},{"categories":["techology"],"content":" 3. 工具集成提供了丰富的工具集成能力： RAG：支持文档检索和知识库构建 Agent：支持复杂任务的规划和执行 ","date":"2025-02-20","objectID":"/langchain4j-tool/:2:3","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#3-工具集成"},{"categories":["techology"],"content":" 4. 应用场景常见的应用场景包括： 智能客服系统 文档处理自动化 AI 辅助编程 ","date":"2025-02-20","objectID":"/langchain4j-tool/:2:4","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#4-应用场景"},{"categories":["techology"],"content":" 总结LangChain4J 提供了完整的 AI 应用开发框架，通过合理使用这些功能模块，可以快速构建强大的 AI 应用。 ","date":"2025-02-20","objectID":"/langchain4j-tool/:3:0","series":null,"tags":["LangChain4J"],"title":"LangChain4J 功能架构详解","uri":"/langchain4j-tool/#总结"},{"categories":["techology"],"content":"详细介绍如何在 SpringBoot 项目中集成 LangChain4J，实现 AI 能力","date":"2025-02-20","objectID":"/springboot-langchain4j/","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/"},{"categories":["techology"],"content":" 简介LangChain4j 是一个强大的 Java AI 开发框架，它可以帮助我们快速构建基于大语言模型的应用。本文将详细介绍如何在 SpringBoot 项目中集成 LangChain4J，并实现一个简单的 AI 聊天应用。 ","date":"2025-02-20","objectID":"/springboot-langchain4j/:1:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#简介"},{"categories":["techology"],"content":" 项目架构graph TD A[SpringBoot Application] --\u003e B[LangChain4J Config] B --\u003e C[ChatLanguageModel] B --\u003e D[MessageMemory] C --\u003e E[OpenAI API] A --\u003e F[ChatService] F --\u003e C F --\u003e D A --\u003e G[ChatController] G --\u003e F style A fill:#f9f,stroke:#333,stroke-width:2px style B fill:#bbf,stroke:#333,stroke-width:2px style C fill:#dfd,stroke:#333,stroke-width:2px style D fill:#dfd,stroke:#333,stroke-width:2px style E fill:#fdd,stroke:#333,stroke-width:2px ","date":"2025-02-20","objectID":"/springboot-langchain4j/:2:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#项目架构"},{"categories":["techology"],"content":" 环境准备 JDK 17+ SpringBoot 3.x Maven/Gradle OpenAI API Key ","date":"2025-02-20","objectID":"/springboot-langchain4j/:3:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#环境准备"},{"categories":["techology"],"content":" 项目配置","date":"2025-02-20","objectID":"/springboot-langchain4j/:4:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#项目配置"},{"categories":["techology"],"content":" Maven 依赖首先在 pom.xml 中添加必要的依赖： xml \u003cdependencies\u003e \u003c!-- SpringBoot 基础依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- LangChain4j 核心依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003edev.langchain4j\u003c/groupId\u003e \u003cartifactId\u003elangchain4j\u003c/artifactId\u003e \u003cversion\u003e0.27.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- LangChain4j Spring 集成 --\u003e \u003cdependency\u003e \u003cgroupId\u003edev.langchain4j\u003c/groupId\u003e \u003cartifactId\u003elangchain4j-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e0.27.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- Lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2025-02-20","objectID":"/springboot-langchain4j/:4:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#maven-依赖"},{"categories":["techology"],"content":" 配置文件在 application.yml 中添加相关配置： yaml langchain4j: chat-model: provider: openai api-key: ${OPENAI_API_KEY} model-name: gpt-4 temperature: 0.7 timeout: 60s base-url: https://your-gpt4-mini-api-endpoint # 如果使用自定义 API ","date":"2025-02-20","objectID":"/springboot-langchain4j/:4:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#配置文件"},{"categories":["techology"],"content":" 核心实现","date":"2025-02-20","objectID":"/springboot-langchain4j/:5:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#核心实现"},{"categories":["techology"],"content":" 项目结构 bash src/main/java/com/example/demo/ ├── config/ │ └── LangChain4jConfig.java ├── service/ │ ├── ChatService.java │ └── PromptService.java ├── controller/ │ └── ChatController.java ├── model/ │ ├── ChatRequest.java │ └── ChatResponse.java └── DemoApplication.java ","date":"2025-02-20","objectID":"/springboot-langchain4j/:5:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#项目结构"},{"categories":["techology"],"content":" 配置类 java @Configuration @Slf4j public class LangChain4jConfig { @Value(\"${langchain4j.chat-model.api-key}\") private String apiKey; @Value(\"${langchain4j.chat-model.base-url}\") private String baseUrl; @Bean public ChatLanguageModel chatLanguageModel() { return OpenAiChatModel.builder() .apiKey(apiKey) .modelName(\"gpt-4\") .baseUrl(baseUrl) .timeout(Duration.ofSeconds(60)) .temperature(0.7) .logRequests(true) .logResponses(true) .build(); } @Bean public MessageMemory messageMemory() { return MessageMemory.withMaxMessages(10); } } ","date":"2025-02-20","objectID":"/springboot-langchain4j/:5:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#配置类"},{"categories":["techology"],"content":" 服务实现 java @Service @Slf4j public class ChatService { private final ChatLanguageModel chatModel; private final MessageMemory memory; public ChatService(ChatLanguageModel chatModel, MessageMemory memory) { this.chatModel = chatModel; this.memory = memory; } public String chat(String userMessage) { try { memory.add(UserMessage.from(userMessage)); String response = chatModel.generate(memory.messages()); memory.add(AiMessage.from(response)); return response; } catch (Exception e) { log.error(\"AI 服务调用失败\", e); throw new AIException(\"AI 服务暂时不可用，请稍后重试\"); } } } ","date":"2025-02-20","objectID":"/springboot-langchain4j/:5:3","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#服务实现"},{"categories":["techology"],"content":" 高级特性","date":"2025-02-20","objectID":"/springboot-langchain4j/:6:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#高级特性"},{"categories":["techology"],"content":" 对话流程 sequenceDiagram participant Client participant Controller participant ChatService participant OpenAI Client-\u003e\u003eController: POST /api/chat Controller-\u003e\u003eChatService: chat(message) ChatService-\u003e\u003eChatService: 添加用户消息到记忆 ChatService-\u003e\u003eOpenAI: 生成回复 OpenAI--\u003e\u003eChatService: 返回回复 ChatService-\u003e\u003eChatService: 添加 AI 回复到记忆 ChatService--\u003e\u003eController: 返回回复 Controller--\u003e\u003eClient: 返回响应 note over Client,OpenAI: 完整的对话流程 ","date":"2025-02-20","objectID":"/springboot-langchain4j/:6:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#对话流程"},{"categories":["techology"],"content":" Prompt 模板使用 java @Service public class PromptService { private final PromptTemplate promptTemplate = PromptTemplate.from( \"你是一个{{role}}，请用专业的角度回答：{{question}}\" ); private final ChatLanguageModel chatModel; public String getResponse(String role, String question) { String prompt = promptTemplate.apply(Parameters.from( \"role\", role, \"question\", question )); return chatModel.generate(prompt); } } ","date":"2025-02-20","objectID":"/springboot-langchain4j/:6:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#prompt-模板使用"},{"categories":["techology"],"content":" 最佳实践 API Key 安全性 使用环境变量或配置中心存储 API Key 避免直接在代码中硬编码敏感信息 定期轮换 API Key 性能优化 使用异步处理长时间运行的 AI 请求 实现请求缓存减少 API 调用 合理设置超时时间和重试策略 成本控制 实现 Token 计数和使用统计 设置调用限额 监控 API 调用成本 ","date":"2025-02-20","objectID":"/springboot-langchain4j/:7:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#最佳实践"},{"categories":["techology"],"content":" 常见问题 如何处理 API 超时？ 建议设置合理的超时时间，并实现重试机制： java @Retryable( value = {TimeoutException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000) ) public String chatWithRetry(String message) { return chatService.chat(message); } ","date":"2025-02-20","objectID":"/springboot-langchain4j/:8:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#常见问题"},{"categories":["techology"],"content":" 总结通过本文的介绍，我们学习了如何在 SpringBoot 项目中集成 LangChain4J，实现了一个基础的 AI 聊天应用。主要包括： 基础配置和依赖管理 核心功能实现 高级特性使用 性能优化和监控 安全性考虑 在实际开发中，建议根据具体需求选择合适的功能特性，同时注意安全性、性能和成本控制等方面的考虑。 ","date":"2025-02-20","objectID":"/springboot-langchain4j/:9:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#总结"},{"categories":["techology"],"content":" 参考资料 LangChain4j 官方文档 SpringBoot 官方文档 OpenAI API 文档 ","date":"2025-02-20","objectID":"/springboot-langchain4j/:10:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"在 SpringBoot 中接入 LangChain4J 开发指南","uri":"/springboot-langchain4j/#参考资料"},{"categories":["techology"],"content":"详细介绍如何使用 SpringBoot 和 LangChain4j 实现一个智能 AI Agent","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/"},{"categories":["techology"],"content":" 什么是 AI Agent？AI Agent 是一个能够自主决策和执行任务的智能代理。它可以： 理解用户意图 规划任务步骤 调用工具完成任务 处理异常情况 持续优化决策 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:1:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#什么是-ai-agent"},{"categories":["techology"],"content":" 系统架构graph TD A[用户请求] --\u003e B[Agent Controller] B --\u003e C[Agent Service] C --\u003e D[任务规划器] C --\u003e E[工具注册中心] D --\u003e F[OpenAI] E --\u003e G[计算器] E --\u003e H[搜索引擎] E --\u003e I[天气查询] F --\u003e C G --\u003e C H --\u003e C I --\u003e C ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:2:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#系统架构"},{"categories":["techology"],"content":" 项目实现","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:3:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#项目实现"},{"categories":["techology"],"content":" 1. Maven 依赖配置 xml \u003cdependencies\u003e \u003c!-- SpringBoot --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- LangChain4j --\u003e \u003cdependency\u003e \u003cgroupId\u003edev.langchain4j\u003c/groupId\u003e \u003cartifactId\u003elangchain4j\u003c/artifactId\u003e \u003cversion\u003e0.27.1\u003c/version\u003e \u003c/dependency\u003e \u003c!-- LangChain4j Agent --\u003e \u003cdependency\u003e \u003cgroupId\u003edev.langchain4j\u003c/groupId\u003e \u003cartifactId\u003elangchain4j-agent\u003c/artifactId\u003e \u003cversion\u003e0.27.1\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:3:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#1-maven-依赖配置"},{"categories":["techology"],"content":" 2. 工具实现 java @Tool public class Calculator { @ToolFunction public double add(double a, double b) { return a + b; } @ToolFunction public double multiply(double a, double b) { return a * b; } } @Tool public class WeatherService { @ToolFunction public String getWeather(String city) { // 调用天气 API return \"晴天，温度 25℃\"; } } ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:3:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#2-工具实现"},{"categories":["techology"],"content":" 3. Agent 服务实现 java @Service @Slf4j public class AIAgentService { private final ChatLanguageModel chatModel; private final ToolRegistry toolRegistry; private final Agent agent; public AIAgentService(ChatLanguageModel chatModel) { this.chatModel = chatModel; this.toolRegistry = new ToolRegistry(); // 注册工具 toolRegistry.registerTool(new Calculator()); toolRegistry.registerTool(new WeatherService()); // 创建 Agent this.agent = Agent.builder() .chatLanguageModel(chatModel) .toolRegistry(toolRegistry) .build(); } public String process(String userInput) { try { AgentResponse response = agent.process(userInput); return response.getOutput(); } catch (Exception e) { log.error(\"Agent 处理失败\", e); return \"抱歉，我现在无法处理这个请求\"; } } } ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:3:3","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#3-agent-服务实现"},{"categories":["techology"],"content":" 4. Controller 实现 java @RestController @RequestMapping(\"/api/agent\") public class AgentController { private final AIAgentService agentService; public AgentController(AIAgentService agentService) { this.agentService = agentService; } @PostMapping(\"/chat\") public ResponseEntity\u003cString\u003e chat(@RequestBody String message) { String response = agentService.process(message); return ResponseEntity.ok(response); } } ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:3:4","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#4-controller-实现"},{"categories":["techology"],"content":" Agent 工作流程 sequenceDiagram participant User as 用户 participant Agent as AI Agent participant LLM as 大语言模型 participant Tools as 工具集 User-\u003e\u003eAgent: 发送请求 Agent-\u003e\u003eLLM: 分析用户意图 LLM--\u003e\u003eAgent: 返回任务分解 loop 任务执行 Agent-\u003e\u003eTools: 调用相关工具 Tools--\u003e\u003eAgent: 返回工具结果 Agent-\u003e\u003eLLM: 结果评估 LLM--\u003e\u003eAgent: 下一步计划 end Agent-\u003e\u003eUser: 返回最终结果 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:4:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#agent-工作流程"},{"categories":["techology"],"content":" 示例场景","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:5:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#示例场景"},{"categories":["techology"],"content":" 1. 数学计算场景用户输入： text 请帮我计算：(23 + 45) * 2 是多少？ Agent 处理流程： 分析出需要使用计算器工具 拆分为加法和乘法两步 调用计算器完成计算 返回结果 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:5:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#1-数学计算场景"},{"categories":["techology"],"content":" 2. 天气查询场景用户输入： text 北京今天天气怎么样？需要带伞吗？ Agent 处理流程： 识别需要查询天气 调用天气服务获取数据 分析是否需要带伞 给出建议 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:5:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#2-天气查询场景"},{"categories":["techology"],"content":" 最佳实践","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:6:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#最佳实践"},{"categories":["techology"],"content":" 1. 错误处理 java public class AgentException extends RuntimeException { public AgentException(String message) { super(message); } } @ControllerAdvice public class AgentExceptionHandler { @ExceptionHandler(AgentException.class) public ResponseEntity\u003cString\u003e handleAgentException(AgentException e) { return ResponseEntity .status(HttpStatus.INTERNAL_SERVER_ERROR) .body(e.getMessage()); } } ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:6:1","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#1-错误处理"},{"categories":["techology"],"content":" 2. 性能优化 性能优化建议 使用工具结果缓存 实现并发任务处理 设置合理的超时时间 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:6:2","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#2-性能优化"},{"categories":["techology"],"content":" 3. 监控指标 java @Service public class AgentMetricsService { private final MeterRegistry registry; public void recordToolUsage(String toolName) { registry.counter(\"agent.tool.usage\", \"tool\", toolName).increment(); } public void recordProcessingTime(long milliseconds) { registry.timer(\"agent.processing.time\").record(milliseconds, TimeUnit.MILLISECONDS); } } ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:6:3","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#3-监控指标"},{"categories":["techology"],"content":" 安全考虑 安全注意事项 工具调用权限控制 用户输入验证 敏感信息保护 调用频率限制 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:7:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#安全考虑"},{"categories":["techology"],"content":" 总结通过 SpringBoot + LangChain4j 实现的 AI Agent 具有以下优势： 架构清晰，易于扩展 工具集成灵活 错误处理完善 性能监控到位 在实际应用中，可以根据具体需求： 添加更多工具 优化决策逻辑 增强安全机制 提升用户体验 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:8:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#总结"},{"categories":["techology"],"content":" 参考资料 LangChain4j Agent 文档 SpringBoot 官方文档 OpenAI API 文档 ","date":"2025-01-20","objectID":"/springboot-langchain4j-agent/:9:0","series":null,"tags":["SpringBoot","LangChain4J"],"title":"SpringBoot + LangChain4j 实现智能 AI Agent","uri":"/springboot-langchain4j-agent/#参考资料"},{"categories":["techology"],"content":"这篇记录详细描述了我从购买域名到配置博客的全过程, 包括选择域名, 注册步骤, DNS 设置及博客平台配置等关键环节. 旨在帮助读者了解每一步的具体操作, 为他们的博客创建提供参考. 这里感谢下赛博佛祖: Cloudfalre ","date":"2024-09-22","objectID":"/configure-domain/:0:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#"},{"categories":["techology"],"content":" 选择方案因为在国内域名要备案, 秉承着 INTP 的懒人思想, 能避免麻烦就避免选择了在国外注册域名, 当然也想着为以后能做点海外的产品或者网站先铺铺路. 通过 Google 和询问了群里的大佬, 一般都是在哪里购买域名, 推荐是 Cloudflare namecheap 对比了下 2 个价格, namecheap 会便宜些, 所以就通过 namecheap 注册了 ","date":"2024-09-22","objectID":"/configure-domain/:1:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#选择方案"},{"categories":["techology"],"content":" 选择域名我一直以来用的 AKA 或者网名都是: L_MaFia , 根据 lmafia 搜索,哪个便宜买哪个, 比如 .info, .xyz, .life 啥的. .info 一年只需要 $2.4 左右, 注意购买的时候最好关闭自动续费,一般续费价格就不划算了,我也当做是练手,可能不一定会使用超过一年时间. ","date":"2024-09-22","objectID":"/configure-domain/:2:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#选择域名"},{"categories":["techology"],"content":" 支付方式namecheap 支持使用 Visa, PayPal 一些常用的国外支付方式, 这也应该难倒了不少网友了,如果我没有 Visa 卡, 全币卡咋办？ 其实,PayPal 是可以关联咱们的银联的储蓄卡的,这次购买一年的域名的花费总购不在 27RMB. 我选择了一张基本不使用的建设银行的储蓄卡,但是在付费扣款时一直出现失败 询问了群里的大佬,应该是有踩坑的经验: 国内一些银联卡可能会无法支付,他是用招商银行的卡支付的 我记得我本科的时候,使用 PayPal 购买过 DigitalOcean 的服务器时用过工行卡,想着还是听大佬的先试试看,为了保险起见的话,打不了支付成功后再解绑即可. 实测下来: 建设银行-无法支付 招商银行-成功支付 ","date":"2024-09-22","objectID":"/configure-domain/:3:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#支付方式"},{"categories":["techology"],"content":" 让域名指向博客我的博客是用 Hugo 搭建的纯静态的网站,白嫖了 Vercel 和 GithPage, 体验下来 Vercel 的访问速度会好些,当然我后续我可能会尝试白嫖 Cloudflare Pages ","date":"2024-09-22","objectID":"/configure-domain/:4:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#让域名指向博客"},{"categories":["techology"],"content":" Cloudfalre 添加域名cf-domain-add ","date":"2024-09-22","objectID":"/configure-domain/:4:1","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#cloudfalre-添加域名"},{"categories":["techology"],"content":" Cloudflare 的免费 SSL想用 HTTPS 就避免不了需要使用 SSL,不仅因为安全考虑,还有如果需要一些域名解析指向应用服务平台,平台也会一定的安全要求 ,Cloudflare 免费提供了 SSL 够我们开发者的博客内容使用了 cf-domain-ssl 一定要选择 Strict , 不然 Vercel 是不会给是指向过去的 ","date":"2024-09-22","objectID":"/configure-domain/:4:2","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#cloudflare-的免费-ssl"},{"categories":["techology"],"content":" Cloudfalre 提供 DNS 服务cf-domain-dns ","date":"2024-09-22","objectID":"/configure-domain/:4:3","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#cloudfalre-提供-dns-服务"},{"categories":["techology"],"content":" Namecheap 配置 DNSNamecheap 提供也 DNS 了,但是因为我们需要 白嫖 SSL 所以需要修改下 DNS 服务列表 Namecheap 提供的教程: How to set up DNS records for your domain in a Cloudflare account 看其中的第三和第四步,大概也就了解了 配置好这个之后,可以说我们的域名就可以交给 Cloudfalre 来 「管理」 了 ","date":"2024-09-22","objectID":"/configure-domain/:4:4","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#namecheap-配置-dns"},{"categories":["techology"],"content":" Cloudfalre 添加 DNS Record这一步就是给用户访问域名的时候, 需要浏览到我们的具体网页地址上 这里我添加了一个 CNAME 规则 CNAME: 域名解析为另外一个域名 cf-domain-dns-cname 当我输入浏览器输入: blog.lmafia.info 时, 会解析到目标地址: Vercel 的博客域名 ","date":"2024-09-22","objectID":"/configure-domain/:4:5","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#cloudfalre-添加-dns-record"},{"categories":["techology"],"content":" Vercel 域名添加配置最后一步就是在 Vercel 给我们博客项目配置域名 我们一直配置好 Cloudfalre 到 Vercel 的单向的配置了 我估计是 Vercel 因为安全原因,还需要配置这个域名并会自动验证 验证可用会有 2 个 ✅ 出现 vercel-domain-add ","date":"2024-09-22","objectID":"/configure-domain/:4:6","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#vercel-域名添加配置"},{"categories":["techology"],"content":" 完成配置接下来, 让我们通过域名访问下该站点吧: https://blog.lmafia.info 成功访问! 恭喜,我们已经完成了给我们的博客配置一个属于自己的域名啦! ","date":"2024-09-22","objectID":"/configure-domain/:5:0","series":null,"tags":["建站"],"title":"域名购买到博客配置的过程记录","uri":"/configure-domain/#完成配置"},{"categories":["techology"],"content":"我的第一篇想要输出的博客内容应该是在大四的时候，那时候应该 COVID-19，都困在家里完成毕业设计和毕业论文。 ","date":"2023-09-29","objectID":"/first-page/:0:0","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#"},{"categories":["techology"],"content":" 为什么创建博客主要是因为我没有博客, 所以我想搭一个, 哈哈哈. 我的第一篇想要输出的博客内容应该是在大四的时候，那时候应该 COVID-19，都困在家里完成毕业设计和毕业论文。 那会的毕业设计算是接了一个坑，是一个 ROS+SLAM 的机器人，老师给了我一个没有任何中文资料的激光雷达，我又去买了一个刚出树莓派 4B 来做系统。 当时的中文资料比较有限，只能靠着自己摸索，和翻墙找资料，最后一点一点填出来。我当时想着既然没有啥中文资料，那不如自己写一个，就在 CSDN 上发了一篇关于在树莓派 4B 搭建 ROS 的博客。 后来毕业之后，就转岗到 Java 开发了，完全从零基础就要上工的过程真的很痛苦，因为我也不是科班的，当时就花钱买了一个网上的培训课程，一心想着学成之后离开那家公司。 当时上课做的笔记，自己总结一下就放到了 CSDN 上，主要是一种炫耀的心情吧，我自己认为最重要的原因就是想放在简历上，可以让面试官觉得自己稍微有点技术追求之类的。 现在的 CSDN 已经在国内的技术圈子里开始臭名昭著了，所以我也不太愿意在上面发东西了。所以后面工作和业余的记录就通过 Typroa 写完上传到 Github 上。 后来就一直用 markdown 记录，不过创建目录、文件应该放在什么位置，对我来说需要耗费心力的事情，我又是一个又懒又拖延的人，这样会让我不愿意去记录东西。后来在网上就刷到了双链笔记的相关文章，非常火的是 notion ，主要我觉得因为它对网络有一定要求，所以不是很喜欢。我还是更希望自己用一个纯本地的文本编辑: obsidian 和 logseq，其实都能满足我的需求了，最后是因为 UI ，选了我自己认为比较轻便的 logseq 。 就这样，我就在 2022 年底，我过上了几乎每天都在记录的日子，记录自己的想法，自己的读书笔记，记录看技术文章或技术视频，记录看到的推文… 1 2 3 随着记录不断增多，让我觉得我可能又只是在做一个小松鼠而已，自己的思考和总结并没有很大的提升。我一昧的记录，对我吸收知识帮助不是特别大。 最近因为尝试把学习练手 Vue3 的静态网站搭建在 Gitub Pages 上，发现并不难。所以想自己尝试把自己的博客搭建起来，通过写博文的方式，让自己有动力去把日常记录的内容总结一下。 ","date":"2023-09-29","objectID":"/first-page/:1:0","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#为什么创建博客"},{"categories":["techology"],"content":" 技术选型","date":"2023-09-29","objectID":"/first-page/:2:0","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#技术选型"},{"categories":["techology"],"content":" 开源博客 Hexo Hugo VuePress VitePress 主要是想体验一下不同的技术，所以选择了基于 go 的 hugo ","date":"2023-09-29","objectID":"/first-page/:2:1","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#开源博客"},{"categories":["techology"],"content":" 服务器直接白嫖 GitHub Pages ","date":"2023-09-29","objectID":"/first-page/:2:2","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#服务器"},{"categories":["techology"],"content":" 编辑器Visual Studio Code 它真的非常适合，既能装 markdown 插件，又能作为 Git 的可视化，还能有 terminal 来方便我们敲命令。 ","date":"2023-09-29","objectID":"/first-page/:2:3","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#编辑器"},{"categories":["techology"],"content":" 需要会什么折腾技术的最不怕不会任何东西， 应该都会有一颗保持好奇的心， 学习应该算是一件比较简单的事情啦， 又加上搜索引擎， 甚至用上如同 ChatGPT 这种的 AI 工具， 还是能解决我们大部分学习需求的吧。 Git: 毕竟要用到 Github, 而且有一定的版本管理还能方便咱们回溯内容 Shell 命令: 安装 ","date":"2023-09-29","objectID":"/first-page/:3:0","series":null,"tags":["建站"],"title":"第一篇博客","uri":"/first-page/#需要会什么"}]