[{"content":"数学公式在编程里的应用: 整数向上取整公式，常用于分页，分片的场景\n背景 在用 AI 编程的时候，让它给我生成一个分页处理的工具类:\npublic static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; paginate(List\u0026lt;T\u0026gt; list, int page, int pageSize) { if (list == null || list.isEmpty()) { return Collections.emptyList(); } if (pageSize \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;pageSize must be greater than 0\u0026#34;); } int total = list.size(); int totalPages = (total + pageSize - 1) / pageSize; int safePage = Math.max(1, page); if (safePage \u0026gt; totalPages) { return Collections.emptyList(); } int skip = (safePage - 1) * pageSize; return list.stream() .skip(skip) .limit(pageSize) .collect(Collectors.toList()); } 在 Review 生成代码的时候，发现求总页数的计算让我有点好奇，为什么它用这个公式 求总页数: 总数除于分页大小, 如果余数大 0，就加一。在编程里，整数相除一般是向下取整，我第一反应想到的逻辑是：先除，后取模，根据取模结果判断是否 +1，btw，看 Mybatis Plus 的代码，发现他也是这么设计的:\n/** * 当前分页总页数 */ default long getPages() { if (getSize() == 0) { return 0L; } long pages = getTotal() / getSize(); if (getTotal() % getSize() != 0) { pages++; } return pages; } 所以 AI 给我的这个计算方式着实让我好奇:\n(total + pageSize - 1) / pageSize;\n我很好奇，为什么是加b-1 和除以b\n所以后来，我向 Chapt 老师请教了如何证明这个公式是有效的。\n证明过程 “向上取整除法”的核心公式是：\n$$ \\left\\lceil \\frac{a}{b} \\right\\rceil = \\frac{a + b - 1}{b} $$\n前提：\na ≥ 0, b \u0026gt; 0 除法采用整数除法（向下取整） 所有变量为整数 目标 我们要证明这个公式：\n$$ \\left\\lceil \\frac{a}{b} \\right\\rceil = \\frac{a + b - 1}{b} $$\n右边是整数除法（向下取整），但通过 +b-1 的技巧实现了向上取整效果。\n整数除法基础（商和余） 设 a = bq + r，其中：\nq = a / b 是向下取整的商 r = a % b 是余数，满足 0 ≤ r \u0026lt; b 因此：\n如果 r = 0：说明 a 被 b 整除，结果无需进位。 如果 r \u0026gt; 0：则需进一位，即向上取整。 定义 定义：\n$$ \\left\\lceil \\frac{a}{b} \\right\\rceil = \\begin{cases} q, \u0026amp; \\text{if } r = 0 \\\\ q + 1, \u0026amp; \\text{if } r \u0026gt; 0 \\end{cases} $$\n分情况讨论 当 r = 0 时 a = bq a + b - 1 = bq + b - 1 代入\n$$ \\frac{a + b - 1}{b} $$\n得到:\n$$ \\frac{a + b - 1}{b} = \\frac{bq + b - 1}{b} = q + \\left( \\frac{b - 1}{b} \\right) $$\n因为整数除法是向下取整的， (b - 1) \u0026lt; b , 所以 (b - 1)/b 为 0\n所以证明得\n$$ \\frac{a + b - 1}{b} = \\frac{b(q + 1) - 1}{b} = q $$\n当 r \u0026gt; 0 时 a = bq + r, 0 \u0026lt; r \u0026lt; b a + b - 1 = bq + r + b - 1 = b(q + 1) + (r - 1) 代入\n$$ \\frac{a + b - 1}{b} $$\n得到:\n$$ \\left( \\frac{a + b - 1}{b} \\right) = \\left( \\frac{b(q + 1) + (r - 1)}{b} \\right) = (q + 1) + \\left( \\frac{r - 1}{b} \\right) $$\n讨论 (r - 1) 和 b 因为 0 \u0026lt; r \u0026lt; b , 所以 -1 \u0026lt; r - 1 \u0026lt; b - 1 \u0026lt; b 得 r-1 \u0026lt; b 所以\n$$ \\left( \\frac{r - 1}{b} \\right) = 0 $$\n所以证明得, 当 r \u0026gt; 0 时\n$$ \\frac{a + b - 1}{b} = (q + 1) + 0 = q + 1 $$\n结语 因为只是涉及整数的运算，用不到浮点运算比 JDK Math提供的 ceil 更适合分页的场景 除此之外，还能用:\n底层的 内存块 / 缓冲区申请 BTW, 和公司的嵌入式同事强哥提到的时候，他能脱口而出这个公式，看来对嵌入式开发来说比较常用\n文件的分块 ，以实现断点续传或分块并行下载 分布式任务调度的 分片计算 大数据任务计算的 批处理 ","permalink":"https://blog.lmafia.info/posts/ceil-for-integers/","summary":"\u003cp\u003e数学公式在编程里的应用: 整数向上取整公式，常用于分页，分片的场景\u003c/p\u003e","title":"整数向上取整公式证明"},{"content":"现在是什么问题? 最近开发环境有个服务只要是超过 2 天没有重启/构建上线的话, 都会出现请求超时的问题.弄的前端和嵌入式开发的同事老是找我麻烦 😅\n周末刚好有空去加班, 办公室也比较安静, 比较有耐心来排查这个问题了.\n开发环境虽然是个直接 java -jar 部署的, 因为有用 mircometer 来暴露一些监控数据, 我也是把它接入了监控了, 在 Grafana 就能看到 JVM 情况\n可以看到 Thread 和 Waithing 状态的 Thread 不断增加, 怎么了, 看起来是线程泄漏了? 我们的代码虽然管理是不规范, 到处都有地方开线程池, 但是之前还是用的好好的呀「手动狗头」\n没事没事, 知道有异常出现了, 都好办, 直接上去机器上 dump 一些 log 出来看看就好, 我们这不还在「犯罪现场」呢嘛\n看看怎么个事儿 开发环境都是丢在一台虚拟机上的, 而且就是直接 java -jar 部署的 天然的让我好把日志导出来, 我直接一个 jps -lvm 查看那个问题服务的 PID\n然后再来一个 jstack:\n通过 jstack pid \u0026gt; thread_dump.log 把线程和上下文都 dump 出来 然后再来请上我们的 Linux 三剑客之二: awk, grep\n这里你以为我的 Linux 命令用的很溜嘛? 其实都是 ChatGPT 给我的, 没了他我可就是个菜鸡 😭\n执行:\nawk \u0026#39;/^\u0026#34;/ {thread=$0} /java.lang.Thread.State: WAITING/ {print thread}\u0026#39; thread_dump.log | awk -F\u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $2}\u0026#39; | tee /dev/tty | wc -l 输出:\n好家伙, 大部分都是 http-nio-exec-* 证明都是请求没有释放还是咋地啊？\n咱们可是都是 Spring Boot 工程师呢 , 用得当然是我们的 SpringBoot + SpringWeb (Tomcat 内置)\n我们最近也没升级啥 Tomcat 的版本, 也没修改什么配置的, 到底咋个回事?\n挑几个请求的线程看看日志吧, 发现基本都处在 WAITING（Park）状态\n而且几乎所有 WAITING 状态的都来自 Druid 数据库连接池获取不到链接, 争抢锁 🔒 时获取不到, 一直等待其他链接的释放.\n我们的在服务配置的 max-active = 20, 说明 20 个链接可能都被占着, 一直没还回去.\n难道是高并发? 是不是要直接把 max-active 调大就可以解决？ 如果我是初级开发, 我可能就会认为这样就能解决了, 毕竟舔了这堆屎山 💩 已经近 3 年之久, 我的直觉告诉我肯定是哪里有 Bug 导致的\n因为还没给 Druid 配置连接泄漏检测, 所以只能通过业务日志排查.因为是一直有线程占数据库连接「不拉屎」, 导致后面的请求「拉不了屎」, 所以我们可以从日志最前面的几个 http 请求线程来看.\n发现均来自给设备升级的业务, 这个业务的接口在开发环境一般是了半夜 2 点定时任务触发的, 很少在从客户端请求\n有点眉目了 本来想看能不能知道几个线程的存活时间, 通过存活时间来推算日志时间来看业务日志, 转念一想, 都已知具体触发时间, 就搭配线程名和业务关键来过滤日志吧, 就在日志的海洋 🌊 里遨游吧, 骚年\n排查了好一会儿, 突然发现有几个 Feign 的调用是报错的, 通过 trace 来看, 看到本应该 2 点开始出发的请求, 在 9 点还有一个报错堆栈:\n奇怪, 怎么有一个 wait 被中断的报错, 而且在 过了 7 个小时才被中断.\njava.lang.InterruptedException: null at java.base/java.lang.Object.wait0(Native Method) at java.base/java.lang.Object.wait(Object.java:366) 找到对应的代码, 发现是同事在解耦一个业务的时候, 想把一个兜底的定时任务去掉, 写成了一个 while(可能会真) 里加了个 object.wait(时间).\n那么我们看下这几个一直 wait 的请求吧.对了, 这里的线程应该是为 TIMED_WAITING 状态, 因为是加了等待时间的, 只是一直在 while 里出不来.\n终于捉到虫 再次请出我们的 Linux 剑客帮帮忙吧, 记得把想要找的线程状态改为 TIMED_WAITING\nawk \u0026#39;/^\u0026#34;/ {thread=$0} /java.lang.Thread.State: TIMED_WAITING/ {print thread}\u0026#39; thread_dump.log | awk -F\u0026#39;\u0026#34;\u0026#39; \u0026#39;{print $2}\u0026#39; 输出内容:\n看了除了 http-nio-exec-280 外的日志, 都是卡在出问题的代码上:\n而且刚好数量和配置的 Druid 的 max-active 一致, 这个 Bug 就在这里被排查出来了.\n因为有个监控会定时调用「登陆」接口来判断服务是否正常, 所以后面 200+ 个请求积压都是来自「登陆」接口.\n学到了啥 和以前排查 bug 不同的是, 这次排查问题读组件源码, 通过报错堆栈搜问题, 以前会在首先会 Google 搜索, 现在首先是发给 ChatGPT.\n虽然 AI 输出的内容可能比较全面, 但是还是会误导我们, 比如这次解决问题时候, 他因为不知道我们业务代码, 第一时间是让我修改数据库连接池的最大活跃数, 都是一个治标不治本的做法, 如果想要思考问题透彻点, 还是多问 Why, 多用第一性原理分析 🧐\n","permalink":"https://blog.lmafia.info/posts/debug-tomcat-thread-issue/","summary":"\u003ch2 id=\"现在是什么问题\"\u003e现在是什么问题?\u003c/h2\u003e\n\u003cp\u003e最近开发环境有个服务只要是超过 2 天没有重启/构建上线的话, 都会出现请求超时的问题.弄的前端和嵌入式开发的同事老是找我麻烦 😅\u003c/p\u003e\n\u003cp\u003e周末刚好有空去加班, 办公室也比较安静, 比较有耐心来排查这个问题了.\u003c/p\u003e\n\u003cp\u003e开发环境虽然是个直接 java -jar 部署的, 因为有用 mircometer 来暴露一些监控数据, 我也是把它接入了监控了, 在 Grafana 就能看到 JVM 情况\u003c/p\u003e\n\u003cp\u003e\n  \u003cimg loading=\"lazy\" src=\"https://image-s3.lmafia.info/data/2025/05/b0b6104f2d306a2c82587bfba8f8ed85.png\" alt=\"Grafana - JVM\"  /\u003e\u003c/p\u003e\n\u003cp\u003e可以看到 Thread 和 Waithing 状态的 Thread 不断增加, 怎么了, 看起来是线程泄漏了? 我们的代码虽然管理是不规范, 到处都有地方开线程池, 但是之前还是用的好好的呀「手动狗头」\u003c/p\u003e\n\u003cp\u003e没事没事, 知道有异常出现了, 都好办, 直接上去机器上 dump 一些 log 出来看看就好, 我们这不还在「犯罪现场」呢嘛\u003c/p\u003e\n\u003ch2 id=\"看看怎么个事儿\"\u003e看看怎么个事儿\u003c/h2\u003e\n\u003cp\u003e开发环境都是丢在一台虚拟机上的, 而且就是直接 \u003ccode\u003ejava -jar\u003c/code\u003e 部署的\n天然的让我好把日志导出来, 我直接一个 \u003ccode\u003ejps -lvm\u003c/code\u003e 查看那个问题服务的 PID\u003c/p\u003e\n\u003cp\u003e然后再来一个 \u003ccode\u003ejstack\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e通过 \u003ccode\u003ejstack pid \u0026gt; thread_dump.log\u003c/code\u003e 把线程和上下文都 dump 出来\n然后再来请上我们的 Linux 三剑客之二: \u003ccode\u003eawk\u003c/code\u003e, \u003ccode\u003egrep\u003c/code\u003e\u003c/p\u003e","title":"SpringWeb 线程泄漏问题排查"},{"content":"我有个不太像一般程序员的特点：我喜欢钻业务。遇到业务问题，我愿意虚心和他们请教交流。不会当下提出我的意见和看法，因为他们才是这方面专家，你过多的建议反而会影响他们对你的看法。\n我更愿意的做法是，下来自己思考和研究，收集资料和问下其他人与 AI ，参考综合的意见。\n可以的话，我再把这些内容在技术团队里面来分享，注意注意，大部分搞技术的人是傲慢的，你只能作为尽量低姿态的分享而已，当然，除非你具有一定的个人魅力，或者说你是领导\n","permalink":"https://blog.lmafia.info/notes/2025/20250323/","summary":"\u003cp\u003e我有个不太像一般程序员的特点：我喜欢钻业务。遇到业务问题，我愿意虚心和他们请教交流。不会当下提出我的意见和看法，因为他们才是这方面专家，你过多的建议反而会影响他们对你的看法。\u003c/p\u003e\n\u003cp\u003e我更愿意的做法是，下来自己思考和研究，收集资料和问下其他人与 AI ，参考综合的意见。\u003c/p\u003e\n\u003cp\u003e可以的话，我再把这些内容在技术团队里面来分享，注意注意，大部分搞技术的人是傲慢的，你只能作为尽量低姿态的分享而已，当然，除非你具有一定的个人魅力，或者说你是领导\u003c/p\u003e","title":"非一般程序员"},{"content":"如何用 Java 使用高阶函数\nFunciton 接口的定义 /** * Represents a function that accepts one argument and produces a result. * * \u0026lt;p\u0026gt;This is a \u0026lt;a href=\u0026#34;package-summary.html\u0026#34;\u0026gt;functional interface\u0026lt;/a\u0026gt; * whose functional method is {@link #apply(Object)}. * * @param \u0026lt;T\u0026gt; the type of the input to the function * @param \u0026lt;R\u0026gt; the type of the result of the function * * @since 1.8 */ @FunctionalInterface public interface Function\u0026lt;T, R\u0026gt; {} 代码示例 实现功能:\n2 次函数 apply 3 次函数 apply public static void main(String[] args) { Function\u0026lt;Function\u0026lt;Integer, Integer\u0026gt;, Function\u0026lt;Integer, Integer\u0026gt;\u0026gt; applyTwice = //f(f(x)) f -\u0026gt; x -\u0026gt; f.apply(f.apply(x)); Function\u0026lt;Function\u0026lt;Integer, Integer\u0026gt;, Function\u0026lt;Integer, Integer\u0026gt;\u0026gt; applyThrice = f -\u0026gt; { return x -\u0026gt; { //f(f(f(x))) return f.apply(f.apply(f.apply(x))); }; }; System.out.println(applyThrice.apply( x -\u0026gt; x + 1 ).apply(0)); } 第一层：最外层 Function Function\u0026lt;Function\u0026lt;Integer, Integer\u0026gt;, Function\u0026lt;Integer, Integer\u0026gt;\u0026gt; 这个类型的输入是 Function\u0026lt;Integer, Integer\u0026gt; 输出也是 Function\u0026lt;Integer, Integer\u0026gt;。\n换句话说，这个高阶函数的作用是：\n接收一个函数 Funciotn\u0026lt;Interger, Integer\u0026gt; 返回一个新的函数 Function\u0026lt;Integer, Integer\u0026gt;， 第二层：输入参数 Function\u0026lt;Integer, Integer\u0026gt;\n这是 Java 函数接口, 输入输出参数都是 Integer\n比如：\nFunction\u0026lt;Integer, Integer\u0026gt; increment = x -\u0026gt; x + 1; Function\u0026lt;Integer, Integer\u0026gt; square = x -\u0026gt; x * x;\n这些都是 Function\u0026lt;Integer, Integer\u0026gt; 类型的函数。\n第三层 返回值 Function\u0026lt;Integer, Integer\u0026gt; 最后 applyThrice 应该返回的是一个Function\u0026lt;Integer, Integer\u0026gt; 拆解下 applyThrice.apply( x -\u0026gt; x + 1 ).apply(0)\napplyThrice.apply( x -\u0026gt; x + 1 ) 返回了: x -\u0026gt; ( ( ( x + 1 ) + 1 ) + 1 ) .apply(0) 就是把 0 作为输入 x ( ( ( 0 + 1 ) + 1 ) + 1 ) 结果为 3 ","permalink":"https://blog.lmafia.info/posts/fucniton-for-java/","summary":"\u003cp\u003e如何用 Java 使用高阶函数\u003c/p\u003e","title":"用 Java 来实现高阶函数"},{"content":"我是谁 Hi, 我是 Kyle Lian\n软件开发, 涉及过数字城市、海外广告和智能家居\n一位 Apple 产品重度用户, 拥有 Apple 全家桶\n目前正在和 AI 一起做一些有意思的事情\n喜欢的编程风格 OOP, FP\n后端 Java, Kotlin, Python Spring Boot, Spring Cloud Maven, Gradle Mybatis, Mybatis Plus MySQL, Redis Kafka, Pulsar, RabbitMQ 前端 Vue3 Vite Tailwind CSS HTML5 CSS3 DevOps Docker Git, GitHub, GitLab Jenkins Grafana 开发工具 IDEA VS Code Postman Cursor 其他 Ubuntu, CentOS Markdown Logseq 网站历史 2024-09-25: 配置自定义域名\n2023-09-29: 通过 Hugo + GithubPages 搭建\n","permalink":"https://blog.lmafia.info/about/index.zh-cn/","summary":"\u003ch2 id=\"我是谁\"\u003e我是谁\u003c/h2\u003e\n\u003cp\u003eHi, 我是 Kyle Lian\u003c/p\u003e\n\u003cp\u003e软件开发, 涉及过数字城市、海外广告和智能家居\u003c/p\u003e\n\u003cp\u003e一位 Apple 产品重度用户, 拥有 Apple 全家桶\u003c/p\u003e\n\u003cp\u003e目前正在和 AI 一起做一些有意思的事情\u003c/p\u003e\n\u003cp\u003e喜欢的编程风格 OOP, FP\u003c/p\u003e\n\u003ch4 id=\"后端\"\u003e后端\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eJava, Kotlin, Python\u003c/li\u003e\n\u003cli\u003eSpring Boot, Spring Cloud\u003c/li\u003e\n\u003cli\u003eMaven, Gradle\u003c/li\u003e\n\u003cli\u003eMybatis, Mybatis Plus\u003c/li\u003e\n\u003cli\u003eMySQL, Redis\u003c/li\u003e\n\u003cli\u003eKafka, Pulsar, RabbitMQ\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"前端\"\u003e前端\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eVue3 Vite\u003c/li\u003e\n\u003cli\u003eTailwind CSS\u003c/li\u003e\n\u003cli\u003eHTML5\u003c/li\u003e\n\u003cli\u003eCSS3\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"devops\"\u003eDevOps\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eDocker\u003c/li\u003e\n\u003cli\u003eGit, GitHub, GitLab\u003c/li\u003e\n\u003cli\u003eJenkins\u003c/li\u003e\n\u003cli\u003eGrafana\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"开发工具\"\u003e开发工具\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eIDEA\u003c/li\u003e\n\u003cli\u003eVS Code\u003c/li\u003e\n\u003cli\u003ePostman\u003c/li\u003e\n\u003cli\u003eCursor\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"其他\"\u003e其他\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eUbuntu, CentOS\u003c/li\u003e\n\u003cli\u003eMarkdown\u003c/li\u003e\n\u003cli\u003eLogseq\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"网站历史\"\u003e网站历史\u003c/h2\u003e\n\u003cp\u003e2024-09-25: 配置自定义域名\u003c/p\u003e\n\u003cp\u003e2023-09-29: 通过 \u003ccode\u003eHugo\u003c/code\u003e + \u003ccode\u003eGithubPages\u003c/code\u003e 搭建\u003c/p\u003e","title":"关于"},{"content":"LangChain4J 功能架构 mindmap root((LangChain4J)) 模型集成 OpenAI ChatGPT GPT-4 Azure OpenAI Anthropic Claude 本地模型 Ollama 核心功能 Prompt Engineering PromptTemplate Few-shot Learning Chain of Thought Memory 消息记忆 对话历史 向量存储 Embedding 文本向量化 相似度搜索 知识库构建 工具集成 RAG 文档加载器 文本分割 向量数据库 Agent 工具调用 任务规划 自主决策 应用场景 智能客服 多轮对话 知识库问答 意图识别 文档处理 自动摘要 信息提取 文档分类 代码助手 代码生成 代码解释 Bug分析 功能模块详解 classDiagram class A{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } class B{ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; } A --\u0026gt; B 1. 模型集成 LangChain4J 支持多种大语言模型的接入，包括：\nOpenAI 的 GPT 系列 Azure OpenAI 服务 Anthropic Claude 本地部署的开源模型 2. 核心功能 核心功能模块提供了构建 AI 应用的基础能力：\nPrompt 工程：模板管理和优化 记忆系统：对话历史管理 向量计算：文本嵌入和相似度计算 3. 工具集成 提供了丰富的工具集成能力：\nRAG：支持文档检索和知识库构建 Agent：支持复杂任务的规划和执行 4. 应用场景 常见的应用场景包括：\n智能客服系统 文档处理自动化 AI 辅助编程 总结 LangChain4J 提供了完整的 AI 应用开发框架，通过合理使用这些功能模块，可以快速构建强大的 AI 应用。\n","permalink":"https://blog.lmafia.info/posts/langchain4j-tool/","summary":"","title":"LangChain4J 功能架构详解"},{"content":"简介 LangChain4j 是一个强大的 Java AI 开发框架，它可以帮助我们快速构建基于大语言模型的应用。本文将详细介绍如何在 SpringBoot 项目中集成 LangChain4J，并实现一个简单的 AI 聊天应用。\n项目架构 graph TD A[SpringBoot Application] --\u0026gt; B[LangChain4J Config] B --\u0026gt; C[ChatLanguageModel] B --\u0026gt; D[MessageMemory] C --\u0026gt; E[OpenAI API] A --\u0026gt; F[ChatService] F --\u0026gt; C F --\u0026gt; D A --\u0026gt; G[ChatController] G --\u0026gt; F style A fill:#f9f,stroke:#333,stroke-width:2px style B fill:#bbf,stroke:#333,stroke-width:2px style C fill:#dfd,stroke:#333,stroke-width:2px style D fill:#dfd,stroke:#333,stroke-width:2px style E fill:#fdd,stroke:#333,stroke-width:2px 环境准备 JDK 17+ SpringBoot 3.x Maven/Gradle OpenAI API Key 项目配置 Maven 依赖 首先在 pom.xml 中添加必要的依赖：\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- SpringBoot 基础依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- LangChain4j 核心依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.27.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- LangChain4j Spring 集成 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.27.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置文件 在 application.yml 中添加相关配置：\nlangchain4j: chat-model: provider: openai api-key: ${OPENAI_API_KEY} model-name: gpt-4 temperature: 0.7 timeout: 60s base-url: https://your-gpt4-mini-api-endpoint # 如果使用自定义 API 核心实现 项目结构 src/main/java/com/example/demo/ ├── config/ │ └── LangChain4jConfig.java ├── service/ │ ├── ChatService.java │ └── PromptService.java ├── controller/ │ └── ChatController.java ├── model/ │ ├── ChatRequest.java │ └── ChatResponse.java └── DemoApplication.java 配置类 @Configuration @Slf4j public class LangChain4jConfig { @Value(\u0026#34;${langchain4j.chat-model.api-key}\u0026#34;) private String apiKey; @Value(\u0026#34;${langchain4j.chat-model.base-url}\u0026#34;) private String baseUrl; @Bean public ChatLanguageModel chatLanguageModel() { return OpenAiChatModel.builder() .apiKey(apiKey) .modelName(\u0026#34;gpt-4\u0026#34;) .baseUrl(baseUrl) .timeout(Duration.ofSeconds(60)) .temperature(0.7) .logRequests(true) .logResponses(true) .build(); } @Bean public MessageMemory messageMemory() { return MessageMemory.withMaxMessages(10); } } 服务实现 @Service @Slf4j public class ChatService { private final ChatLanguageModel chatModel; private final MessageMemory memory; public ChatService(ChatLanguageModel chatModel, MessageMemory memory) { this.chatModel = chatModel; this.memory = memory; } public String chat(String userMessage) { try { memory.add(UserMessage.from(userMessage)); String response = chatModel.generate(memory.messages()); memory.add(AiMessage.from(response)); return response; } catch (Exception e) { log.error(\u0026#34;AI 服务调用失败\u0026#34;, e); throw new AIException(\u0026#34;AI 服务暂时不可用，请稍后重试\u0026#34;); } } } 高级特性 对话流程 sequenceDiagram participant Client participant Controller participant ChatService participant OpenAI Client-\u0026gt;\u0026gt;Controller: POST /api/chat Controller-\u0026gt;\u0026gt;ChatService: chat(message) ChatService-\u0026gt;\u0026gt;ChatService: 添加用户消息到记忆 ChatService-\u0026gt;\u0026gt;OpenAI: 生成回复 OpenAI--\u0026gt;\u0026gt;ChatService: 返回回复 ChatService-\u0026gt;\u0026gt;ChatService: 添加 AI 回复到记忆 ChatService--\u0026gt;\u0026gt;Controller: 返回回复 Controller--\u0026gt;\u0026gt;Client: 返回响应 note over Client,OpenAI: 完整的对话流程 Prompt 模板使用 @Service public class PromptService { private final PromptTemplate promptTemplate = PromptTemplate.from( \u0026#34;你是一个{{role}}，请用专业的角度回答：{{question}}\u0026#34; ); private final ChatLanguageModel chatModel; public String getResponse(String role, String question) { String prompt = promptTemplate.apply(Parameters.from( \u0026#34;role\u0026#34;, role, \u0026#34;question\u0026#34;, question )); return chatModel.generate(prompt); } } 最佳实践 使用环境变量或配置中心存储 API Key\n避免直接在代码中硬编码敏感信息\n定期轮换 API Key\n使用异步处理长时间运行的 AI 请求\n实现请求缓存减少 API 调用\n合理设置超时时间和重试策略\n实现 Token 计数和使用统计\n设置调用限额\n监控 API 调用成本\n常见问题 建议设置合理的超时时间，并实现重试机制：\n@Retryable( value = {TimeoutException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000) ) public String chatWithRetry(String message) { return chatService.chat(message); } 总结 通过本文的介绍，我们学习了如何在 SpringBoot 项目中集成 LangChain4J，实现了一个基础的 AI 聊天应用。主要包括：\n基础配置和依赖管理 核心功能实现 高级特性使用 性能优化和监控 安全性考虑 在实际开发中，建议根据具体需求选择合适的功能特性，同时注意安全性、性能和成本控制等方面的考虑。\n参考资料 LangChain4j 官方文档 SpringBoot 官方文档 OpenAI API 文档 ","permalink":"https://blog.lmafia.info/posts/springboot-langchain4j/","summary":"","title":"在 SpringBoot 中接入 LangChain4J 开发指南"},{"content":"什么是 AI Agent？ AI Agent 是一个能够自主决策和执行任务的智能代理。它可以：\n理解用户意图 规划任务步骤 调用工具完成任务 处理异常情况 持续优化决策 系统架构 graph TD A[用户请求] --\u0026gt; B[Agent Controller] B --\u0026gt; C[Agent Service] C --\u0026gt; D[任务规划器] C --\u0026gt; E[工具注册中心] D --\u0026gt; F[OpenAI] E --\u0026gt; G[计算器] E --\u0026gt; H[搜索引擎] E --\u0026gt; I[天气查询] F --\u0026gt; C G --\u0026gt; C H --\u0026gt; C I --\u0026gt; C 项目实现 1. Maven 依赖配置 \u0026lt;dependencies\u0026gt; \u0026lt;!-- SpringBoot --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- LangChain4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.27.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- LangChain4j Agent --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-agent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.27.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2. 工具实现 @Tool public class Calculator { @ToolFunction public double add(double a, double b) { return a + b; } @ToolFunction public double multiply(double a, double b) { return a * b; } } @Tool public class WeatherService { @ToolFunction public String getWeather(String city) { // 调用天气 API return \u0026#34;晴天，温度 25℃\u0026#34;; } } 3. Agent 服务实现 @Service @Slf4j public class AIAgentService { private final ChatLanguageModel chatModel; private final ToolRegistry toolRegistry; private final Agent agent; public AIAgentService(ChatLanguageModel chatModel) { this.chatModel = chatModel; this.toolRegistry = new ToolRegistry(); // 注册工具 toolRegistry.registerTool(new Calculator()); toolRegistry.registerTool(new WeatherService()); // 创建 Agent this.agent = Agent.builder() .chatLanguageModel(chatModel) .toolRegistry(toolRegistry) .build(); } public String process(String userInput) { try { AgentResponse response = agent.process(userInput); return response.getOutput(); } catch (Exception e) { log.error(\u0026#34;Agent 处理失败\u0026#34;, e); return \u0026#34;抱歉，我现在无法处理这个请求\u0026#34;; } } } 4. Controller 实现 @RestController @RequestMapping(\u0026#34;/api/agent\u0026#34;) public class AgentController { private final AIAgentService agentService; public AgentController(AIAgentService agentService) { this.agentService = agentService; } @PostMapping(\u0026#34;/chat\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; chat(@RequestBody String message) { String response = agentService.process(message); return ResponseEntity.ok(response); } } Agent 工作流程 sequenceDiagram participant User as 用户 participant Agent as AI Agent participant LLM as 大语言模型 participant Tools as 工具集 User-\u0026gt;\u0026gt;Agent: 发送请求 Agent-\u0026gt;\u0026gt;LLM: 分析用户意图 LLM--\u0026gt;\u0026gt;Agent: 返回任务分解 loop 任务执行 Agent-\u0026gt;\u0026gt;Tools: 调用相关工具 Tools--\u0026gt;\u0026gt;Agent: 返回工具结果 Agent-\u0026gt;\u0026gt;LLM: 结果评估 LLM--\u0026gt;\u0026gt;Agent: 下一步计划 end Agent-\u0026gt;\u0026gt;User: 返回最终结果 示例场景 1. 数学计算场景 用户输入：\n请帮我计算：(23 + 45) * 2 是多少？ Agent 处理流程：\n分析出需要使用计算器工具 拆分为加法和乘法两步 调用计算器完成计算 返回结果 2. 天气查询场景 用户输入：\n北京今天天气怎么样？需要带伞吗？ Agent 处理流程：\n识别需要查询天气 调用天气服务获取数据 分析是否需要带伞 给出建议 最佳实践 1. 错误处理 public class AgentException extends RuntimeException { public AgentException(String message) { super(message); } } @ControllerAdvice public class AgentExceptionHandler { @ExceptionHandler(AgentException.class) public ResponseEntity\u0026lt;String\u0026gt; handleAgentException(AgentException e) { return ResponseEntity .status(HttpStatus.INTERNAL_SERVER_ERROR) .body(e.getMessage()); } } 2. 性能优化 使用工具结果缓存 实现并发任务处理 设置合理的超时时间 3. 监控指标 @Service public class AgentMetricsService { private final MeterRegistry registry; public void recordToolUsage(String toolName) { registry.counter(\u0026#34;agent.tool.usage\u0026#34;, \u0026#34;tool\u0026#34;, toolName).increment(); } public void recordProcessingTime(long milliseconds) { registry.timer(\u0026#34;agent.processing.time\u0026#34;).record(milliseconds, TimeUnit.MILLISECONDS); } } 安全考虑 工具调用权限控制 用户输入验证 敏感信息保护 调用频率限制 总结 通过 SpringBoot + LangChain4j 实现的 AI Agent 具有以下优势：\n架构清晰，易于扩展 工具集成灵活 错误处理完善 性能监控到位 在实际应用中，可以根据具体需求：\n添加更多工具 优化决策逻辑 增强安全机制 提升用户体验 参考资料 LangChain4j Agent 文档 SpringBoot 官方文档 OpenAI API 文档 ","permalink":"https://blog.lmafia.info/posts/springboot-langchain4j-agent/","summary":"","title":"SpringBoot + LangChain4j 实现智能 AI Agent"},{"content":"这篇记录详细描述了我从购买域名到配置博客的全过程, 包括选择域名, 注册步骤, DNS 设置及博客平台配置等关键环节. 旨在帮助读者了解每一步的具体操作, 为他们的博客创建提供参考. 这里感谢下赛博佛祖: Cloudfalre\n选择方案 因为在国内域名要备案, 秉承着 INTP 的懒人思想, 能避免麻烦就避免选择了在国外注册域名, 当然也想着为以后能做点海外的产品或者网站先铺铺路. 通过 Google 和询问了群里的大佬, 一般都是在哪里购买域名, 推荐是\nCloudflare namecheap 对比了下 2 个价格, namecheap 会便宜些, 所以就通过 namecheap 注册了\n选择域名 我一直以来用的 AKA 或者网名都是: L_MaFia , 根据 lmafia 搜索,哪个便宜买哪个, 比如 .info, .xyz, .life 啥的. .info 一年只需要 $2.4 左右, 注意购买的时候最好关闭自动续费,一般续费价格就不划算了,我也当做是练手,可能不一定会使用超过一年时间.\n支付方式 namecheap 支持使用 Visa, PayPal 一些常用的国外支付方式, 这也应该难倒了不少网友了,如果我没有 Visa 卡, 全币卡咋办？ 其实,PayPal 是可以关联咱们的银联的储蓄卡的,这次购买一年的域名的花费总购不在 27RMB.\n我选择了一张基本不使用的建设银行的储蓄卡,但是在付费扣款时一直出现失败\n询问了群里的大佬,应该是有踩坑的经验: 国内一些银联卡可能会无法支付,他是用招商银行的卡支付的\n我记得我本科的时候,使用 PayPal 购买过 DigitalOcean 的服务器时用过工行卡,想着还是听大佬的先试试看,为了保险起见的话,打不了支付成功后再解绑即可.\n实测下来:\n建设银行-无法支付 招商银行-成功支付 让域名指向博客 我的博客是用 Hugo 搭建的纯静态的网站,白嫖了 Vercel 和 GithPage, 体验下来 Vercel 的访问速度会好些,当然我后续我可能会尝试白嫖 Cloudflare Pages\nCloudfalre 添加域名 Cloudflare 的免费 SSL 想用 HTTPS 就避免不了需要使用 SSL,不仅因为安全考虑,还有如果需要一些域名解析指向应用服务平台,平台也会一定的安全要求 ,Cloudflare 免费提供了 SSL 够我们开发者的博客内容使用了\n一定要选择 Strict , 不然 Vercel 是不会给是指向过去的\nCloudfalre 提供 DNS 服务 Namecheap 配置 DNS Namecheap 提供也 DNS 了,但是因为我们需要 白嫖 SSL 所以需要修改下 DNS 服务列表 Namecheap 提供的教程:\nHow to set up DNS records for your domain in a Cloudflare account 看其中的第三和第四步,大概也就了解了\n配置好这个之后,可以说我们的域名就可以交给 Cloudfalre 来 「管理」 了\nCloudfalre 添加 DNS Record 这一步就是给用户访问域名的时候, 需要浏览到我们的具体网页地址上 这里我添加了一个 CNAME 规则\nCNAME: 域名解析为另外一个域名 当我输入浏览器输入: blog.lmafia.info 时, 会解析到目标地址: Vercel 的博客域名\nVercel 域名添加配置 最后一步就是在 Vercel 给我们博客项目配置域名 我们一直配置好 Cloudfalre 到 Vercel 的单向的配置了 我估计是 Vercel 因为安全原因,还需要配置这个域名并会自动验证 验证可用会有 2 个 ✅ 出现\n完成配置 接下来, 让我们通过域名访问下该站点吧: https://blog.lmafia.info\n成功访问!\n恭喜,我们已经完成了给我们的博客配置一个属于自己的域名啦!\n","permalink":"https://blog.lmafia.info/posts/configure-domain/","summary":"\u003cp\u003e这篇记录详细描述了我从购买域名到配置博客的全过程, 包括选择域名, 注册步骤, DNS 设置及博客平台配置等关键环节.\n旨在帮助读者了解每一步的具体操作, 为他们的博客创建提供参考.\n这里感谢下赛博佛祖: \u003ccode\u003eCloudfalre\u003c/code\u003e\u003c/p\u003e","title":"域名购买到博客配置的过程记录"},{"content":"我的第一篇想要输出的博客内容应该是在大四的时候，那时候应该 COVID-19，都困在家里完成毕业设计和毕业论文。\n为什么创建博客 主要是因为我没有博客, 所以我想搭一个, 哈哈哈.\n我的第一篇想要输出的博客内容应该是在大四的时候，那时候应该 COVID-19，都困在家里完成毕业设计和毕业论文。\n那会的毕业设计算是接了一个坑，是一个 ROS+SLAM 的机器人，老师给了我一个没有任何中文资料的激光雷达，我又去买了一个刚出树莓派 4B 来做系统。 当时的中文资料比较有限，只能靠着自己摸索，和翻墙找资料，最后一点一点填出来。我当时想着既然没有啥中文资料，那不如自己写一个，就在 CSDN 上发了一篇关于在树莓派 4B 搭建 ROS 的博客。\n后来毕业之后，就转岗到 Java 开发了，完全从零基础就要上工的过程真的很痛苦，因为我也不是科班的，当时就花钱买了一个网上的培训课程，一心想着学成之后离开那家公司。\n当时上课做的笔记，自己总结一下就放到了 CSDN 上，主要是一种炫耀的心情吧，我自己认为最重要的原因就是想放在简历上，可以让面试官觉得自己稍微有点技术追求之类的。 现在的 CSDN 已经在国内的技术圈子里开始臭名昭著了，所以我也不太愿意在上面发东西了。所以后面工作和业余的记录就通过 Typroa 写完上传到 Github 上。\n后来就一直用 markdown 记录，不过创建目录、文件应该放在什么位置，对我来说需要耗费心力的事情，我又是一个又懒又拖延的人，这样会让我不愿意去记录东西。后来在网上就刷到了双链笔记的相关文章，非常火的是 notion ，主要我觉得因为它对网络有一定要求，所以不是很喜欢。我还是更希望自己用一个纯本地的文本编辑: obsidian 和 logseq，其实都能满足我的需求了，最后是因为 UI ，选了我自己认为比较轻便的 logseq 。\n就这样，我就在 2022 年底，我过上了几乎每天都在记录的日子，记录自己的想法，自己的读书笔记，记录看技术文章或技术视频，记录看到的推文\u0026hellip;\n随着记录不断增多，让我觉得我可能又只是在做一个小松鼠而已，自己的思考和总结并没有很大的提升。我一昧的记录，对我吸收知识帮助不是特别大。 最近因为尝试把学习练手 Vue3 的静态网站搭建在 Gitub Pages 上，发现并不难。所以想自己尝试把自己的博客搭建起来，通过写博文的方式，让自己有动力去把日常记录的内容总结一下。\n技术选型 开源博客 Hexo Hugo VuePress VitePress 主要是想体验一下不同的技术，所以选择了基于 go 的 hugo\n服务器 直接白嫖 GitHub Pages\n编辑器 Visual Studio Code\n它真的非常适合，既能装 markdown 插件，又能作为 Git 的可视化，还能有 terminal 来方便我们敲命令。\n需要会什么 折腾技术的最不怕不会任何东西， 应该都会有一颗保持好奇的心， 学习应该算是一件比较简单的事情啦， 又加上搜索引擎， 甚至用上如同 ChatGPT 这种的 AI 工具， 还是能解决我们大部分学习需求的吧。\nGit: 毕竟要用到 Github, 而且有一定的版本管理还能方便咱们回溯内容 Shell 命令: 安装 ","permalink":"https://blog.lmafia.info/posts/first-page/","summary":"\u003cp\u003e我的第一篇想要输出的博客内容应该是在大四的时候，那时候应该 \u003ccode\u003eCOVID-19\u003c/code\u003e，都困在家里完成毕业设计和毕业论文。\u003c/p\u003e","title":"第一篇博客"}]